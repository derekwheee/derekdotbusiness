{{!--
    title: Derek Learns to Unit Test, Part 1
    subtitle: I'll figure it out
    date: 2016-12-09T19:59
--}}

<h1>Derek Learns to Unit Test, Part 1</h1>

<p>
    I've written unit tests before, for
    <a href="https://github.com/rwaldron/johnny-five/">Johnny-Five</a>, but
    always with the benefit of existing tests to use as reference. As part of
    building this new site I decided to implement unit tests for every aspect.
    Here I will attempt to document my experience learning how to really <!DOCTYPE html>
    good unit tests.
</p>

<h2>derek.business/architecture</h2>

<p>
    Let's quickly go over the JavaScript architecture of this site. It's a little weird.
    The server is an <a href="http://expressjs.com/"><strong>Express</strong></a>
    server running on <a href="https://heroku.com/"><strong>Heroku</strong></a>.
    The view engine is
    <a href="http://handlebarsjs.com/"><strong>Handlebars</strong></a>
    implemented using
    <a href="https://github.com/ericf/express-handlebars"><strong>express-handlebars</strong></a>.
    If you want to just look at the code
    <a href="https://github.com/frxnz/derekdotbusiness">go to here</a>.
</p>

<p>
    Right off the bat, without implementing anything more than a simple blog
    there are a few things there to test:

    <ul>
        <li>The Express server starts and runs on a specific port.</li>
        <li>The specified routes are able to be hit.</li>
        <li>The post loader loads the posts in the correct format.</li>
        <li>Each of the Handlebars helpers perform as designed.</li>
    </ul>
</p>

<h2>Choosing a test runner</h2>

<p>
    There are several very good options for test runners in the JavaScript
    ecosystem. I'm going to be using
    <a href="https://github.com/avajs/ava">AVA</a>. Why? It's new, it's
    interesting, it's fast, and
    <a href="https://github.com/sindresorhus">Sindre Sorhus</a> has built some
    of my favorite development tools. Most importantly it's the one which
    confused me the least when trying to make a decision.
</p>

<p>
    That's it.
</p>

<h2>Writing the first test</h2>

<p>
    The first thing I want to test is the Express server. I want to make sure it
    starts, uses the right port, and I'm able to hit the routes I've defined.
    I know this is going to require some HTTP requests which will be async. AVA
    supports promises for async tests, so I'll use
    <a href="https://github.com/request/request-promise">request-promise</a> to
    make the requests.
</p>

<pre><code class="language-js">import test from 'ava';
import request from 'request-promise';

const options = {
    method : 'GET',
    uri : 'http://localhost:5000/',
    resolveWithFullResponse : true
};

test(t => {
    return request(options).then(result => {
        t.is(result.statusCode, 200);
    });
});
</code></pre>

<p>
    Fairly straightforward. We make a GET request to the local dev site, and
    once the promise returns we check that the results contain a status code of
    200. There is one small problem, which is that this test will only work if
    the local dev server is running before you start the tests. We want these
    tests to be self-contained, so let's fix that.
</p>

<p>
    To do that we need to make some changes to our server. If you've seen an
    Express server module before you're probably accustomed to them not having
    a <code>module.exports</code>. This is usually fine, because the server is
    the entry point for the application, and is not usually required by other
    modules. However, for this test I want to be able to start and stop the
    server. Starting it is easy, you just require the module. But stopping it
    requires access to the <code>.close()</code> function on the server. That's
    actually a function on the underlying <code>http</code> instance, and not
    the Express app. Right now the server is created here:
</p>

<pre><code class="language-js">// ...
app.listen(app.get('port'), () => {
  console.log('Node app is running on port', app.get('port'));
});
</code></pre>

<p>
    All we need to do is assign that to something we can export, and export it:
</p>

<pre><code class="language-js">// ...
server = app.listen(app.get('port'), () => {
  console.log('Node app is running on port', app.get('port'));
});

module.exports = {
    server : server,
    app : app
};
</code></pre>

<p>
    I'm also exporting the Express app because I know I'll need that for another
    test later.
</p>

<p>
    With that done we can add the setup and teardown for our server test.
</p>

<pre><code class="language-js">import test from 'ava';
import request from 'request-promise';

const options = {
    method : 'GET',
    uri : 'http://localhost:5000/',
    resolveWithFullResponse : true
};
var express;

test.before(t => {
    express = require('../server.js');
});

test.after(t => {
    express.server.close();
})

test(t => {
    return request(options).then(result => {
        t.is(result.statusCode, 200);
    });
});
</code></pre>

<p>
    Now when the test runs the server will automatically be started, and then
    when the test is done the server will but shut down.
</p>
